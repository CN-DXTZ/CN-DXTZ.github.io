<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

	<title>DXTZ</title>
	<link rel="icon" href="/images/favicon.ico">

	
<link rel="stylesheet" href="/css/style.css">

	<link href="//at.alicdn.com/t/font_1660778_ufn05bndyb.css" rel="stylesheet">
	
	<link href="//cdn.jsdelivr.net/gh/CN-DXTZ/CN-DXTZ.github.io/css/third%20party/prism.min.css" rel="stylesheet">
	
	<link href="//cdn.jsdelivr.net/gh/CN-DXTZ/CN-DXTZ.github.io/css/third%20party/jquery.fancybox.min.css" rel="stylesheet">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header class="header">

	<div class="blog-title">
		<a href="/">DXTZ</a>
	</div>

	<nav class="navbar">
		<ul class="menu">
			
			<li class="menu-item">

				<a href="/" class="menu-item-link">
					首页
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/categories" class="menu-item-link">
					分类
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/archives" class="menu-item-link">
					归档
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/tags" class="menu-item-link">
					标签
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/about" class="menu-item-link">
					关于
				</a>

			</li>
			
		</ul>
	</nav>

</header>

    <main class="main">
        <section class="posts">
	<article class="post">
    <div class="post-header">
    <h1 class="post-title">
        <a class="post-title-link" href="/JAVA/JAVA Core/多线程/">
            多线程
        </a>
    </h1>

    <div class="post-info">

        <span class="post-date">
            <i class="iconfont icon-calendar"></i>
            2020-03-05
        </span>

        <span class="post-words">
            <i class="iconfont icon-write"></i>
            3.2k字
        </span>

        <span class="post-readtime">
            <i class="iconfont icon-shijian"></i>
            13分钟
        </span>

    </div>

    <div class="post-belong">

        <span class="post-tags">
            <i class="iconfont icon-tags"></i>
            
            <a href="/tags/线程/"> 线程</a> <a href="/tags/多线程/"> 多线程</a> <a href="/tags/JAVA-Core/"> JAVA Core</a>
        </span>

        <span class="post-categories">
            <i class="iconfont icon-folderopen"></i>
            
            <a href="/categories/JAVA/"> JAVA</a> / <a href="/categories/JAVA/JAVA-Core/"> JAVA Core</a>
        </span>
    </div>
</div>

    <div class="post-content">
        <a id="more"></a>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线程和进程的概念：</p>
<ul>
<li>进程：程序进入内存后的程序实例。  <ul>
<li>每个进程都独占使用主存（虚拟内存），即都有独立的代码和数据空间（进程上下文）。</li>
<li>进程的创建、释放、切换的开销大。</li>
</ul>
</li>
<li>线程：线程是程序内部的顺序控制流，可视作轻量的进程。<ul>
<li>每个线程都运行在各自进程的虚拟内存中，即共享代码和数据空间；<br>但每个线程有独立的运行栈和程序计数器。</li>
<li>线程的创建、释放、切换的开销小，内部通信效率高。</li>
</ul>
</li>
</ul>
<p>多进程和多线程的概念：</p>
<ul>
<li>多进程：在操作系统中，能同时运行多个进程</li>
<li>多线程：在进程中，能同时运行多个顺序控制流（线程）</li>
</ul>
<p>并行和并发的概念：</p>
<ul>
<li>并行：计算机在同一时刻同时执行多条指令</li>
<li>并发：通过使计算机在多个正在执行的进程间来回切换，实现各进程的指令交错执行，形成多个进程在一个时间段内并行的假象，即多个进程的逻辑控制流在时间段上有重叠</li>
</ul>
<h3 id="线程的简单使用"><a href="#线程的简单使用" class="headerlink" title="线程的简单使用"></a>线程的简单使用</h3><p>线程的概念模型为 <code>java.lang.Thread</code>，通过该类可实现线程的使用，以下介绍两种常用的方法简单实现线程实例化调用：</p>
<h4 id="Override-run"><a href="#Override-run" class="headerlink" title="Override run()"></a>Override run()</h4><p>Thread类内部有一个run()方法，通过继承Thread类并重写run()方法，即可定义所需的线程派生子类，然后通过其start()方法即可启动线程，自动运行run()方法，具体的：</p>
<p>首先定义一个Thread的派生子类，并重写其run()方法：</p>
<pre><code class="lang-java">class MyRun extends Thread {
    private int sleepTime;

    public MyRun(String name) {
        super(name);
        sleepTime = (int) (Math.random() * 6000);
    }

    @Override
    public void run() {
        try {
            System.out.println(getName() + &quot; will sleep &quot; + sleepTime);
            Thread.sleep(sleepTime);
        } catch (Exception e) {
        }
        System.out.println(getName() + &quot; finished&quot;);
    }
}
</code></pre>
<p>再在主方法内实例化线程派生子类并通过start()方法调用线程：</p>
<pre><code class="lang-java">class ThreadMain {
    public static void main(String args[]) {
        System.out.println(&quot;ThreadMain Starting:&quot;);
        for (int i = 1; i &lt;= 3; i++) {
            new MyRun(&quot;run-&quot; + i).start();
        }
        System.out.println(&quot;ThreadMain end!&quot;);
    }
}
</code></pre>
<p>其运行结果如下：</p>
<blockquote>
<p>ThreadMain Starting:<br>  ThreadMain end!<br>  run-3 will sleep 3404<br>  run-1 will sleep 5259<br>  run-2 will sleep 715<br>  run-2 finished<br>  run-3 finished<br>  run-1 finished  </p>
</blockquote>
<p>显然，从结果可以发现以下几点：</p>
<ul>
<li>main()方法就是一个（主）线程</li>
<li>run()方法无需直接通过调用执行，而是通过Thread的派生类实例调用start()方法启动线程，然后自动执行线程的run()方法</li>
<li>多个线程并发执行，（随机）抢占CPU的执行调度</li>
</ul>
<p>具体的运行时的内存分配过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/Thread_1.png" alt="Thread_1.png"></p>
<h4 id="implements-Runnable"><a href="#implements-Runnable" class="headerlink" title="implements Runnable"></a>implements Runnable</h4><p>Runnable的特性：</p>
<ul>
<li>Runnable接口只有一个方法——run()方法</li>
<li>Thread类实现了Runnable接口——<code>public class Thread implements Runnable {}</code></li>
<li>Runnable的使用：<ol>
<li>以实现Runnable接口的类的实例化对象构造Thread——<code>Thread(Runnable target);</code></li>
<li>依旧通过start()方法启动线程自动执行run()方法</li>
</ol>
</li>
</ul>
<p>具体的代码如下（已高亮关键变化）：</p>
<ol>
<li>首先类似继承Thread实现Runnable重写run()</li>
<li>然后实例化实现Runnable接口的类</li>
<li>再把实例化Runnable对象传递给Thread用于构造Thread对象</li>
<li>最后通过Thread对象start()方法启动线程，自动调用run()方法</li>
</ol>
<pre><code class="lang-diff-java">/* MyRunnable.java */
- class MyRun extends Thread {
+ class MyRunnable implements Runnable {
    private int sleepTime;

    public MyRunnable() {
        this.sleepTime = (int) (Math.random() * 6000);
    }

    @Override
    public void run() {
        try {
-           System.out.println(getName() + &quot; will sleep &quot; + sleepTime);
+           System.out.println(Thread.currentThread().getName() + &quot; will sleep &quot; + sleepTime);
            Thread.sleep(sleepTime);
        } catch (Exception e) {
        }
-       System.out.println(getName() + &quot; finished&quot;);
+       System.out.println(Thread.currentThread().getName() + &quot; finished&quot;);
    }
}

/* ThreadMain.java */
class ThreadMain {
    public static void main(String args[]) {
        System.out.println(&quot;ThreadMain Starting:&quot;);
        for (int i = 1; i &lt;= 3; i++) {
-           new MyRun(&quot;thread-&quot; + i).start();
+           MyRunnable mr = new MyRunnable(&quot;thread-&quot; + i);
+           new Thread(mr).start();
        }
        System.out.println(&quot;ThreadMain end!&quot;);
    }
}
</code></pre>
<p>其结果类似如下：</p>
<blockquote>
<p>ThreadMain Starting:<br>  ThreadMain end!<br>  Runnable-3 will sleep 1259<br>  Runnable-1 will sleep 139<br>  Runnable-2 will sleep 4226<br>  Runnable-1 finished<br>  Runnable-3 finished<br>  Runnable-2 finished</p>
</blockquote>
<p>二者的区别：</p>
<ul>
<li>（继承Thread）直接重写run()：<ul>
<li>优点：<ul>
<li>编写简单，直接继承重写run()即可</li>
<li>可直接使用Thread的方法</li>
</ul>
</li>
<li>缺点：<ul>
<li>Java不支持多继承，不能再继承其他类</li>
</ul>
</li>
</ul>
</li>
<li>实现Runnable（重写run()）：<ul>
<li>优点：<ul>
<li>解耦，</li>
<li>可继承其他类，避免单继承的局限性</li>
<li>便于多个线程间数据共享，run()和线程独立，可以被多个线程共享</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="线程的数据共享"><a href="#线程的数据共享" class="headerlink" title="线程的数据共享"></a>线程的数据共享</h3><p>之前已经提及了，通过Runnable可实现数据共享。而上述实现Runnable接口的例子中，每次启动线程所传递的Runnable对象都是新构造的，而假如每个线程构造时传递的都是同一个Runnable对象，即实现了线程间的数据共享。</p>
<p>以下通过一个简单的3个员工售票的小例子介绍如何通过Runnable实现数据共享（共享了同一个票数变量<code>amount</code>）：</p>
<pre><code class="lang-java">/* Office.class */
class Office {
    public static void main(String args[]) {
        Staff s = new Staff();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Staff-&quot; + i).start();
        }
    }
}

/* Staff.class */
class Staff implements Runnable {
    private int amount = 7;

    @Override
    public void run() {
        while (amount &gt; 0) {
            if (amount &gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount--);
            }
        }
    }
}
</code></pre>
<p>运行结果如下：</p>
<blockquote>
<p>Staff-1 is selling 7<br>  Staff-3 is selling 5<br>  Staff-2 is selling 6<br>  Staff-3 is selling 3<br>  Staff-1 is selling 4<br>  Staff-3 is selling 1<br>  Staff-2 is selling 2</p>
</blockquote>
<h3 id="线程的同步与互斥"><a href="#线程的同步与互斥" class="headerlink" title="线程的同步与互斥"></a>线程的同步与互斥</h3><p>仍然是上述多线程数据共享的例子，通过稍微修改代码，通过分开amount的输出语句和自减语句，并在售票前休眠1ms提高不同线程同时访问票数值变量amount的几率，暴露可能出现的BUG：</p>
<pre><code class="lang-diff-java">/* Office.class */
class Office {
    public static void main(String args[]) {
        Staff s = new Staff();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Staff-&quot; + i).start();
        }
    }
}

/* Staff.class */
class Staff implements Runnable {
    private int amount = 7;

    @Override
    public void run() {
        while (amount &gt; 0) {
            if (amount &gt; 0) {
-               System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount--);
+               try {
+                   Thread.sleep(1);
+               } catch (Exception e) {
+               }
+               System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
+               amount--;
            }
        }
    }
}
</code></pre>
<p>则会造成如下的结果：</p>
<blockquote>
<p>Staff-1 is selling 7<br>  Staff-3 is selling 7<br>  Staff-2 is selling 7<br>  Staff-3 is selling 4<br>  Staff-1 is selling 4<br>  Staff-2 is selling 4<br>  Staff-1 is selling 2<br>  Staff-3 is selling 2<br>  Staff-2 is selling -1</p>
</blockquote>
<p>可以看出，由于三个Staff线程同时访问amount，出现了错误：</p>
<ul>
<li>重复卖出第7张票，第4张票</li>
<li>卖出了不存在的第-1张票（可能是：<ol>
<li>Staff-2第4张票还没卖完，Staff-1和Staff-3正在卖第2张票；</li>
<li>Staff-2终于卖完了，但此时amount=2，<code>amount--</code>后amount=1；</li>
<li>Staff-2开始准备卖第1张票，但输出语句还没执行完；</li>
<li>Staff-1和Staff-3卖完了第2张票，但此时amount=1，<code>amount--</code>两次后amount=-1；</li>
<li>Staff-3继续执行输出语句卖第-1张票）</li>
</ol>
</li>
</ul>
<p>通过上述例子可以说明：<br>线程之间往往不完全独立，而是需要访问同一个共享数据，所以需要同步控制。<br>但若不同线程在同一时刻访问同一个共享数据，则会出现BUG，故此时需要保证线程的互斥。线程互斥需要确保线程对同一个共享数据的操作互不干扰，即同一时刻只能有一个线程访问该共享数据。</p>
<p>JVM提供了监视区，在其内部的代码块或方法同一时刻只能被一个线程执行。</p>
<p>Java通过锁机制保证线程的互斥。每个对象只有一个锁，利用多线程对锁的争抢实现线程互斥，当一个线程获取锁对象后，其他线程必须等待该线程执行完规定的操作并释放锁后，才能获取该锁对象继续执行。以下介绍两种锁：</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 是线程同步关键字，可以实现线程的同步互斥，是一种隐式监视器，其特征如下：</p>
<ul>
<li>用于指定需要线程同步的代码块或方法，即监视区，确保其内部的代码线程互斥</li>
<li>具体原理——当执行到对应的代码块或方法时：<br>首先判断对象的锁是否存在：<ul>
<li>如果锁存在，就获取锁，然后执行对应的代码块或方法，直到执行完毕该线程释放锁</li>
<li>如果锁不存在（锁已被其他线程获取），则该线程进入等待状态，直到上一个线程释放锁。<br>其实synchronized可以视作将其指定的代码变为原子操作，不会被线程打散执行。<br>使用方法：</li>
</ul>
</li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><pre><code class="lang-java">synchronized(Object obj){ // 锁对象，可以为任意类型
    // 可能出现线程安全问题的代码，即访问了共享数据的代码
}
</code></pre>
<p>通过同步代码块修复上述BUG：</p>
<pre><code class="lang-diff-java">/* Office.class */
class Office {
    public static void main(String args[]) {
        Staff s = new Staff();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Staff-&quot; + i).start();
        }
    }
}

/* Staff.class */
class Staff implements Runnable {
    private int amount = 7;
+   private Object obj = new Object();

    @Override
    public void run() {
        while (amount &gt; 0) {
+           synchronized (obj) {
                if (amount &gt; 0) {
                    try {
                        Thread.sleep(1);
                    } catch (Exception e) {
                    }
                    System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
                    amount--;
                }
+           }
        }
    }
}
</code></pre>
<p>运行结果如下（正确）：</p>
<blockquote>
<p>Staff-3 is selling 7<br>  Staff-3 is selling 6<br>  Staff-3 is selling 5<br>  Staff-3 is selling 4<br>  Staff-3 is selling 3<br>  Staff-3 is selling 2<br>  Staff-3 is selling 1</p>
</blockquote>
<p>注：</p>
<ul>
<li>都是Staff-3售票是因为同步代码块运行时被锁定，其他线程等待，而恰好同步代码块运行完后，进行while判断时短暂时间被其他线程抢占的几率较小。</li>
<li>若增大总数amount则可能出现其他Staff售票</li>
</ul>
<p>具体的整个过程：当线程执行到synchronized时：</p>
<ol>
<li>检查传入的对象，并申请得到该对象的锁</li>
<li>如果该锁不存在（已被其他线程获取），则该线程放入与该对象锁对应的等待线程池中。</li>
<li>直到该对象锁被释放，池中的等待线程才开始抢占调度，才能重新去获取锁，然后继续往下执行</li>
</ol>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>除了以上对指定的代码块进行同步控制外，还可以通过synchronized关键字指定整个方法线程同步，具体如下：</p>
<pre><code class="lang-java">修饰符 synchronized 返回值 方法名(参数列表){
    // 可能出现线程安全问题的代码，即访问了共享数据的代码
}
</code></pre>
<p>注：</p>
<ol>
<li>同步方法的锁对象是方法所在类的对象，即<code>this</code></li>
<li>静态同步方法的锁对象是方法所在类的class属性（class文件对象），即<code>className.class</code></li>
</ol>
<p>而通过同步方法修复上述BUG：</p>
<pre><code class="lang-diff-java">/* Office.class */
class Office {
    public static void main(String args[]) {
        Staff s = new Staff();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Staff-&quot; + i).start();
        }
    }
}

/* Staff.class */
class Staff implements Runnable {
    private int amount = 7;

    @Override
    public void run() {
        while (amount &gt; 0) {
-           if (amount &gt; 0) {
-               try {
-                   Thread.sleep(1);
-               } catch (Exception e) {
-               }
-               System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
-               amount--;
-           }
+           sell();
        }
    }

+   private synchronized void sell() {
+       if (amount &gt; 0) {
+           try {
+               Thread.sleep(1);
+           } catch (Exception e) {
+           }
+           System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
+           amount--;
+       }
+   }
}
</code></pre>
<h4 id="synchronized-特点"><a href="#synchronized-特点" class="headerlink" title="synchronized 特点"></a>synchronized 特点</h4><ul>
<li>只能同步代码块或方法，不能同步变量</li>
<li>每个java对象有且只有一个作为实现同步的锁，这个锁称为内置锁。</li>
<li>线程进入同步代码块或方法的时候会自动获取锁，在退出同步代码块或方法时会自动释放锁。在当前线程未释放锁时，其他线程只能进入该对象锁对应的等待线程池等待</li>
<li>线程可以获取多个锁。比如在某个同步方法内调用另一个同步方法。</li>
<li>线程sleep时，其持有的任何锁不会被释放</li>
<li>同步会损害并发性，应尽可能减小同步范围</li>
</ul>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>通过synchronized关键字已经可以实现线程的同步，然而其锁的获取和释放是自动的，要想手动获取和释放锁，则可通过 java.util.concurrent.locks.Lock 接口获取更广泛的锁操作。<br>该接口的常用方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">lock()</td>
<td style="text-align:center">获取锁</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">unlock()</td>
<td style="text-align:center">释放锁</td>
</tr>
</tbody>
</table>
</div>
<p>java.util.concurrent.locks.ReentrantLock 实现了 Lock 接口，使用该类步骤如下：</p>
<ol>
<li>在成员变量中创建 ReentrantLock 对象</li>
<li>在可能出现线程安全问题的代码前，使用lock() </li>
<li>在可能出现线程安全问题的代码后，使用unlock()</li>
</ol>
<p>按此方法修复上述BUG：</p>
<pre><code class="lang-diff-java">/* Office.class */
class Office {
    public static void main(String args[]) {
        Staff s = new Staff();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Staff-&quot; + i).start();
        }
    }
}

/* Staff.class */
+ import java.util.concurrent.locks.Lock;
+ import java.util.concurrent.locks.ReentrantLock;

class Staff implements Runnable {
    private int amount = 7;
+   Lock l = new ReentrantLock();

    @Override
    public void run() {
        while (amount &gt; 0) {
+           l.lock();
            if (amount &gt; 0) {
                try {
                    Thread.sleep(1);
                } catch (Exception e) {
                }
                System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
                amount--;
            }
+           l.unlock();
        }
    }
}
</code></pre>
<p>更好的写法：</p>
<pre><code class="lang-java">lock.lock();
try {
    // 可能出现线程安全问题的代码
} finally {
    lock.unlock(); // 无论程序是否异常，都会释放锁
}
</code></pre>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2>
    </div>

    <div class="post-nav">
        <span class="post-nav-prev">
            
        </span>
        <span class="post-nav-next">
            
            <a href="/%E6%9D%82/%E6%80%BB%E7%BB%93/2020%20%E5%B9%B4%203%20%E6%9C%88/" rel="next" title="2020 年 3 月">
                2020 年 3 月<i class="iconfont icon-qianjin"></i>
            </a>
            
        </span>
    </div>
</article>

<div class="post-toc">
    <div class="toc-title">
        <i class="iconfont icon-mulu"></i>
        文章目录
        <span>
            <i class="iconfont icon-houtui"></i>
        </span>
    </div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的简单使用"><span class="toc-number">1.2.</span> <span class="toc-text">线程的简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Override-run"><span class="toc-number">1.2.1.</span> <span class="toc-text">Override run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implements-Runnable"><span class="toc-number">1.2.2.</span> <span class="toc-text">implements Runnable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步"><span class="toc-number">2.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的数据共享"><span class="toc-number">2.1.</span> <span class="toc-text">线程的数据共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的同步与互斥"><span class="toc-number">2.2.</span> <span class="toc-text">线程的同步与互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">2.3.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步代码块"><span class="toc-number">2.3.1.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方法"><span class="toc-number">2.3.2.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-特点"><span class="toc-number">2.3.3.</span> <span class="toc-text">synchronized 特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">2.4.</span> <span class="toc-text">Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间通信"><span class="toc-number">3.</span> <span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的生命周期"><span class="toc-number">4.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程优先级"><span class="toc-number">5.</span> <span class="toc-text">线程优先级</span></a></li></ol>
</div>
</section>	

    </main>

    <div class="footer">
	<div class="platform">
		
			
			
				<a class="iconfont icon-gmail"  href="mailto:dengbin1213@gmail.com" target="_blank"></a>
							
		
			
			
				<a class="iconfont icon-github"  href="https://github.com/CN-DXTZ" target="_blank"></a>
							
		
			
			
				<a class="iconfont icon-zhihu"  href="https://www.zhihu.com/people/DXTZ/" target="_blank"></a>
							
		
			
			
				<a class="iconfont icon-qq-email"  href="mailto:2924380441@qq.com" target="_blank"></a>
							
		
			
							
		
			
							
		
	</div>
	
	<div class="copyright-info">
			<span>Copyright © 2020 - 2020</span>
			<a href="/">DXTZ</a> 
	</div>
</div>

    <div class="after-footer">

    
<script src="/js/navbar.js"></script>


    
<script src="/js/littleCode.js"></script>


    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/instantpage.min.js"type="module"></script>

    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/jquery.min.js"></script>

    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/vanilla-back-to-top.min.js"></script>
    
<script src="/js/addBackToTop.js"></script>


    
        <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/jquery.fancybox.min.js"type="module"></script>
        
<script src="/js/jquery.fancybox.image.js"></script>


        
<script src="/js/jquery.toc.js"></script>

    

    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist@V1.2/source/js/third%20party/prism.min.js" type="module"></script>

</div>
</body>

</html>