<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

	<title>DXTZ</title>
	<link rel="icon" href="/images/favicon.ico">

	
<link rel="stylesheet" href="/css/style.css">

	<link href="//at.alicdn.com/t/font_1660778_ufn05bndyb.css" rel="stylesheet">
	
	<link href="//cdn.jsdelivr.net/gh/CN-DXTZ/CN-DXTZ.github.io/css/third%20party/prism.min.css" rel="stylesheet">
	
	<link href="//cdn.jsdelivr.net/gh/CN-DXTZ/CN-DXTZ.github.io/css/third%20party/jquery.fancybox.min.css" rel="stylesheet">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header class="header">

	<div class="blog-title">
		<a href="/">DXTZ</a>
	</div>

	<nav class="navbar">
		<ul class="menu">
			
			<li class="menu-item">

				<a href="/" class="menu-item-link">
					首页
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/categories" class="menu-item-link">
					分类
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/archives" class="menu-item-link">
					归档
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/tags" class="menu-item-link">
					标签
				</a>

			</li>
			
			<li class="menu-item">

				<a href="/about" class="menu-item-link">
					关于
				</a>

			</li>
			
		</ul>
	</nav>

</header>

    <main class="main">
        <section class="posts">
	<article class="post">
    <div class="post-header">
    <h1 class="post-title">
        <a class="post-title-link" href="/多线程入门/">
            多线程入门
        </a>
    </h1>

    <div class="post-info">

        <span class="post-date">
            <i class="iconfont icon-calendar"></i>
            2020-03-05
        </span>

        <span class="post-words">
            <i class="iconfont icon-write"></i>
            5.1k字
        </span>

        <span class="post-readtime">
            <i class="iconfont icon-shijian"></i>
            20分钟
        </span>

    </div>

    <div class="post-belong">

        <span class="post-tags">
            <i class="iconfont icon-tags"></i>
            
            <a href="/tags/线程/"> 线程</a> <a href="/tags/多线程/"> 多线程</a> <a href="/tags/同步/"> 同步</a> <a href="/tags/锁/"> 锁</a>
        </span>

        <span class="post-categories">
            <i class="iconfont icon-folderopen"></i>
            
            <a href="/categories/JAVA/"> JAVA</a> / <a href="/categories/JAVA/JAVA-Core/"> JAVA Core</a> / <a href="/categories/JAVA/JAVA-Core/多线程/"> 多线程</a>
        </span>
    </div>
</div>

    <div class="post-content">
        <h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线程和进程：</p>
<ul>
<li>进程：程序载入内存后的程序实例，是系统运行程序的基本单位。  <ul>
<li>每个进程都<strong>独占使用主存</strong>（虚拟内存），即都有独立的代码和数据空间（进程上下文）。</li>
<li>进程的创建、释放、切换的开销大。</li>
</ul>
</li>
<li>线程：线程是程序内部的顺序控制流，可视作轻量的进程，是进程执行，CPU调度的基本单位。<ul>
<li>每个线程都运行在各自进程的虚拟内存中，即<strong>共享代码和数据空间</strong>；<br>但每个线程有<strong>独立的运行栈和程序计数器</strong>。</li>
<li>线程的创建、释放、切换的开销小，内部通信效率高。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>多进程和多线程：</p>
<ul>
<li>多进程：在操作系统中，能同时运行多个进程</li>
<li>多线程：在进程中，能同时运行多个顺序控制流（线程）</li>
</ul>
<p>并行和并发：</p>
<ul>
<li>并行：计算机在<strong>同一时刻</strong>同时执行多个进程</li>
<li>并发：计算机在<strong>同一时间段</strong>同时执行多个进程，即通过使计算机在多个正在执行的进程间来回快速切换，实现各进程在同一时间段交错执行，类似在一个时间段并行的假象，即多个进程的逻辑控制流在时间段上有重叠。</li>
</ul>
<h3 id="线程的简单使用"><a href="#线程的简单使用" class="headerlink" title="线程的简单使用"></a>线程的简单使用</h3><p><code>java.lang.Thread</code> 包提供了Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。通过该类实例可实现线程的创建和启动，以下介绍两种实例化的方法实现线程调用：</p>
<h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><p>Thread类内部有一个run()方法，在线程启动后，run()方法的方法体会自动进入该线程的本地方法栈，即该方法体代表了该线程的任务，故称其为线程执行体。</p>
<p>通过继承Thread类来重写run()方法实现线程执行体，通过Thread子类对象start()方法实现线程启动，具体的步骤如下：</p>
<ol>
<li>通过继承Thread类，重写其run()方法，定义所需的线程执行体</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用Thread子类对象的start()方法启动线程，自动运行run()方法</li>
</ol>
<p>以下用一个简单的例子作为演示：</p>
<p>首先定义一个Thread的子类，并重写其run()方法：</p>
<pre><code class="lang-java">class MyRun extends Thread {
    private int sleepTime;

    public MyRun(String name) {
        super(name);
        sleepTime = (int) (Math.random() * 6000);
    }

    @Override
    public void run() {
        try {
            System.out.println(getName() + &quot; will sleep &quot; + sleepTime);
            Thread.sleep(sleepTime);
        } catch (Exception e) {
        }
        System.out.println(getName() + &quot; finished&quot;);
    }
}
</code></pre>
<p>再在主方法内实例化Thread子类并通过start()方法启动该线程：</p>
<pre><code class="lang-java">class ThreadMain {
    public static void main(String args[]) {
        System.out.println(&quot;ThreadMain Starting:&quot;);
        for (int i = 1; i &lt;= 3; i++) {
            new MyRun(&quot;run-&quot; + i).start();
        }
        System.out.println(&quot;ThreadMain end!&quot;);
    }
}
</code></pre>
<p>其运行结果如下：</p>
<blockquote>
<p>ThreadMain Starting:<br>  ThreadMain end!<br>  run-3 will sleep 3404<br>  run-1 will sleep 5259<br>  run-2 will sleep 715<br>  run-2 finished<br>  run-3 finished<br>  run-1 finished  </p>
</blockquote>
<p>显然，从结果可以发现以下几点：</p>
<ul>
<li>进程启动，创建主线程，执行main()方法</li>
<li>run()方法无需通过直接调用执行，而是通过Thread.start()方法启动线程，然后run()方法自动进入该线程的本地方法栈，自动执行</li>
<li>多个线程（包括主线程）并发执行，（随机）抢占CPU的执行调度</li>
</ul>
<p>具体的运行时的内存分配过程如下：<br><img src="https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/Thread_1_3.png" alt="Thread_1_3.png"></p>
<h4 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h4><p>之前是通过继承Thread类重写run()方法实现的线程执行体，而本质上Thread类的run()方法来源于实现Runnable函数式接口——<code>public class Thread implements Runnable {}</code><br><code>java.lang.Runnable</code> 包提供了Runnable函数式接口，该函数式接口提供的唯一的抽象方法即为run()方法。</p>
<p>使用方法类似，通过<del>继承Thread类</del>实现Runnable接口来重写run()方法实现线程执行体，再通过<del>Thread子类对象</del>将Runnable实现类对象传递给Thread（<code>Thread(Runnable target)</code>）构造Thread类对象，最后依旧通过start()方法启动线程，具体的步骤如下：</p>
<ol>
<li>实现Runnable接口重写run()（类似继承Thread）</li>
<li>实例化Runnable接口的实现类对象</li>
<li>把Runnable实现类对象传递给Thread用于构造Thread类对象</li>
<li>调用Thread类对象start()方法启动线程，自动调用run()方法</li>
</ol>
<p>用Runnable的方法重写上述演示如下：</p>
<pre><code class="lang-diff-java">/* MyRunnable.java */
- class MyRun extends Thread {
+ class MyRunnable implements Runnable {
    private int sleepTime;

    public MyRunnable() {
        this.sleepTime = (int) (Math.random() * 6000);
    }

    @Override
    public void run() {
        try {
-           System.out.println(getName() + &quot; will sleep &quot; + sleepTime);
+           System.out.println(Thread.currentThread().getName() + &quot; will sleep &quot; + sleepTime);
            Thread.sleep(sleepTime);
        } catch (Exception e) {
        }
-       System.out.println(getName() + &quot; finished&quot;);
+       System.out.println(Thread.currentThread().getName() + &quot; finished&quot;);
    }
}

/* ThreadMain.java */
class ThreadMain {
    public static void main(String args[]) {
        System.out.println(&quot;ThreadMain Starting:&quot;);
        for (int i = 1; i &lt;= 3; i++) {
-           new MyRun(&quot;thread-&quot; + i).start();
+           MyRunnable mr = new MyRunnable(&quot;thread-&quot; + i);
+           new Thread(mr).start();
        }
        System.out.println(&quot;ThreadMain end!&quot;);
    }
}
</code></pre>
<p>其结果类似如下：</p>
<blockquote>
<p>ThreadMain Starting:<br>  ThreadMain end!<br>  Runnable-3 will sleep 1259<br>  Runnable-1 will sleep 139<br>  Runnable-2 will sleep 4226<br>  Runnable-1 finished<br>  Runnable-3 finished<br>  Runnable-2 finished</p>
</blockquote>
<p>实现Runnable接口比继承Thread类所具有的优势：</p>
<ul>
<li>便于多个线程间数据共享。Runnable实现类对象可以被多个线程共享</li>
<li>可继承其他类，避免单继承的局限性</li>
<li>解耦。线程执行体和线程类对象独立</li>
<li><em>线程池只能放入Runable或Callable的实现类，不能直接放入继承Thread的类</em></li>
</ul>
<h2 id="线程同步——锁机制"><a href="#线程同步——锁机制" class="headerlink" title="线程同步——锁机制"></a>线程同步——锁机制</h2><h3 id="线程安全之数据共享"><a href="#线程安全之数据共享" class="headerlink" title="线程安全之数据共享"></a>线程安全之数据共享</h3><h4 id="线程的数据共享"><a href="#线程的数据共享" class="headerlink" title="线程的数据共享"></a>线程的数据共享</h4><p>之前通过Runnable实现线程执行体时已经提及了，通过Runnable可实现线程的数据共享。<br>而上述实现Runnable接口的例子中，每次启动线程所传递的Runnable对象都是新构造的。但假如每个线程构造时传递的都是同一个Runnable对象，则可以实现线程间的数据共享。</p>
<p>以下通过一个简单的3个员工售票的小例子介绍如何通过Runnable实现数据共享：</p>
<pre><code class="lang-java">/* Office.java */
class Office {
    public static void main(String args[]) {
        Salesperson s = new Salesperson();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Salesperson-&quot; + i).start();
        }
    }
}

/* Salesperson.java */
class Salesperson implements Runnable {
    private int amount = 7;

    @Override
    public void run() {
        while (amount &gt; 0) {
            if (amount &gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount--);
            }
        }
    }
}
</code></pre>
<p>运行结果如下：</p>
<blockquote>
<p>Salesperson-1 is selling 7<br>  Salesperson-3 is selling 5<br>  Salesperson-2 is selling 6<br>  Salesperson-3 is selling 3<br>  Salesperson-1 is selling 4<br>  Salesperson-3 is selling 1<br>  Salesperson-2 is selling 2</p>
</blockquote>
<p>以上即可发现，三个Salesperson共享了同一个票数变量<code>amount</code></p>
<h4 id="数据共享的线程安全问题"><a href="#数据共享的线程安全问题" class="headerlink" title="数据共享的线程安全问题"></a>数据共享的线程安全问题</h4><p>其实直接进行线程间的数据共享会存在线程安全的问题。<br>仍然是上述多线程数据共享的例子，稍微修改代码以提高线程安全问题出现的几率，如下：</p>
<pre><code class="lang-diff-java">/* Office.java */
class Office {
    public static void main(String args[]) {
        Salesperson s = new Salesperson();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Salesperson-&quot; + i).start();
        }
    }
}

/* Salesperson.java */
class Salesperson implements Runnable {
    private int amount = 7;

    @Override
    public void run() {
        while (amount &gt; 0) {
            if (amount &gt; 0) {
-               System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount--);
+               try {
+                   Thread.sleep(1);
+               } catch (Exception e) {
+               }
+               System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
+               amount--;
            }
        }
    }
}
</code></pre>
<p>则会造成如下的结果：</p>
<blockquote>
<p>Salesperson-1 is selling 7<br>  Salesperson-3 is selling 7<br>  Salesperson-2 is selling 7<br>  Salesperson-3 is selling 4<br>  Salesperson-1 is selling 4<br>  Salesperson-2 is selling 4<br>  Salesperson-1 is selling 2<br>  Salesperson-3 is selling 2<br>  Salesperson-2 is selling -1</p>
</blockquote>
<p>可以看出，由于三个Salesperson同时访问amount，出现了错误：</p>
<ul>
<li>重复卖出第7张票，第4张票</li>
<li>卖出了不存在的第-1张票（可能是：<ol>
<li>Salesperson-2正在卖第4张票，但输出语句还没执行完，而Salesperson-1和Salesperson-3已经开始卖第2张票了，即amount=2；</li>
<li>Salesperson-2卖完了第4张票，但此时amount=2，<code>amount--</code>后，amount=1；</li>
<li>Salesperson-2开始准备卖第1张票，但输出语句还没执行完；</li>
<li>Salesperson-1和Salesperson-3卖完了第2张票，但此时amount=1，<code>amount--</code>两次后，amount=-1；</li>
<li>Salesperson-3继续执行输出语句，卖第-1张票）</li>
</ol>
</li>
</ul>
<h4 id="线程的同步与互斥"><a href="#线程的同步与互斥" class="headerlink" title="线程的同步与互斥"></a>线程的同步与互斥</h4><p>通过上述的例子可以说明：<br>线程之间往往不完全独立，常常需要访问同一个共享数据。<br>但若不同线程在同一时刻访问同一个共享数据，且多个线程中对共享资源有写操作时，则容易出现线程安全问题。故此时需要同步控制，保证线程的互斥，确保线程对同一个共享数据的操作互不干扰，即同一时刻只能有一个线程访问该共享数据。</p>
<p>java通过锁机制实现线程的同步互斥。<br>每个对象只有一个锁，利用多线程对锁的争抢实现线程互斥，当一个线程获得锁对象后，其他线程必须等待该线程执行完规定的操作并释放锁后，才能获得该锁对象继续执行。以下介绍两种锁：</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 是线程同步关键字，可以实现线程的同步互斥，是一种隐式监视器，其特征如下：</p>
<ul>
<li>synchronized 用于指定需要线程同步的代码块或方法，即监视区，监视区确保了内部的同步代码线程同步互斥</li>
<li>线程进入同步代码时会自动获得锁，在退出同步代码块或方法时会自动释放锁；<br>只有获得锁的线程才能执行同步代码，在锁未被释放时，其他线程只能进入该对象的锁对应的等待线程池等待。</li>
<li>具体遇到执行到同步代码时，首先判断对象的锁是否存在：<ul>
<li>如果锁存在，就获得锁，然后执行对应的代码块或方法，直到执行完毕该线程释放锁</li>
<li>如果锁不存在（锁已被其他线程获得），则该线程进入等待状态，直到上一个线程释放锁。  </li>
</ul>
</li>
<li>锁对象可以是任意类型。每个java对象<strong>有且只有一个</strong>作为实现同步的锁，这个锁被称为内部锁（Monitor）。<br>任何时候，最多允许一个线程拥有同步对象的锁。（但一个线程可以获得多个不同对象的锁。比如在某个同步方法内再调用另一个同步方法。）</li>
<li>synchronized 可以视作将同步代码变为原子操作，不会被线程打散执行</li>
<li>线程sleep时，其持有的任何锁不会被释放；线程wait时，其持有的锁会被释放</li>
<li><strong>同步会损害并发性，应尽可能减小同步范围</strong></li>
</ul>
<p>synchronized的使用方法分为同步代码块和同步方法两种，如下：</p>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><pre><code class="lang-java">synchronized(Object obj){ // 锁对象
    // 可能出现线程安全问题的代码，即访问了共享数据的代码
}
</code></pre>
<p>当线程执行到synchronized时：</p>
<ol>
<li>检查传入的对象，并申请得到该对象的锁</li>
<li>如果该锁不存在（已被其他线程获得），则该线程放入与该对象锁对应的等待线程池中。</li>
<li>直到该对象锁被释放，池中的等待线程才开始抢占调度，才能重新去获得锁，然后继续往下执行</li>
</ol>
<p>使用同步代码块解决上述线程安全问题：</p>
<pre><code class="lang-diff-java">/* Office.java */
class Office {
    public static void main(String args[]) {
        Salesperson s = new Salesperson();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Salesperson-&quot; + i).start();
        }
    }
}

/* Salesperson.java */
class Salesperson implements Runnable {
    private int amount = 7;
+   private Object obj = new Object();

    @Override
    public void run() {
        while (amount &gt; 0) {
+           synchronized (obj) {
                if (amount &gt; 0) {
                    try {
                        Thread.sleep(1);
                    } catch (Exception e) {
                    }
                    System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
                    amount--;
                }
+           }
        }
    }
}
</code></pre>
<p>运行结果如下（正确）：</p>
<blockquote>
<p>Salesperson-3 is selling 7<br>  Salesperson-3 is selling 6<br>  Salesperson-3 is selling 5<br>  Salesperson-3 is selling 4<br>  Salesperson-3 is selling 3<br>  Salesperson-3 is selling 2<br>  Salesperson-3 is selling 1</p>
</blockquote>
<p>注：</p>
<ul>
<li>都是Salesperson-3售票是因为同步代码块运行时被锁定，其他线程等待，而恰好同步代码块运行完后，只需进行while判断，耗时很短，被其他线程抢占的几率较小。</li>
<li>若增大总数amount则可能出现其他Salesperson售票的情况</li>
</ul>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>除了以上对指定的代码块进行同步控制外，还可以使用synchronized关键字指定整个方法线程同步，具体如下：</p>
<pre><code class="lang-java">修饰符 synchronized 返回值 方法名(参数列表){
    // 可能出现线程安全问题的代码，即访问了共享数据的代码
}
</code></pre>
<p>注：</p>
<ol>
<li>对于非static同步方法的锁对象是方法所在类的实例化对象，即<code>this</code></li>
<li>对于static同步方法的锁对象是方法所在类的class属性，即字节码对象（<code>类名.class</code>）</li>
</ol>
<p>使用同步方法解决上述线程安全问题：</p>
<pre><code class="lang-diff-java">/* Office.java */
class Office {
    public static void main(String args[]) {
        Salesperson s = new Salesperson();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Salesperson-&quot; + i).start();
        }
    }
}

/* Salesperson.java */
class Salesperson implements Runnable {
    private int amount = 7;

    @Override
    public void run() {
        while (amount &gt; 0) {
-           if (amount &gt; 0) {
-               try {
-                   Thread.sleep(1);
-               } catch (Exception e) {
-               }
-               System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
-               amount--;
-           }
+           sell();
        }
    }

+   private synchronized void sell() {
+       if (amount &gt; 0) {
+           try {
+               Thread.sleep(1);
+           } catch (Exception e) {
+           }
+           System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
+           amount--;
+       }
+   }
}
</code></pre>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>通过synchronized关键字已经可以实现线程的同步，然而其锁的获得和释放是自动的。<br>而要想手动获得和释放锁，java则通过 <code>java.util.concurrent.locks.Lock</code> 接口提供了更为广泛的锁操作。<br>该接口的常用方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">lock()</td>
<td style="text-align:center">获得同步锁</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">unlock()</td>
<td style="text-align:center">释放同步锁</td>
</tr>
</tbody>
</table>
</div>
<p><code>java.util.concurrent.locks.ReentrantLock</code> 实现了 Lock 接口，使用该类步骤如下：</p>
<ol>
<li>在成员变量中创建 ReentrantLock 对象</li>
<li>在可能出现线程安全问题的代码前，使用Lock.lock() </li>
<li>在可能出现线程安全问题的代码后，使用Lock.unlock()</li>
</ol>
<p>按此方法解决上述线程安全问题：</p>
<pre><code class="lang-diff-java">/* Office.java */
class Office {
    public static void main(String args[]) {
        Salesperson s = new Salesperson();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Salesperson-&quot; + i).start();
        }
    }
}

/* Salesperson.java */
+ import java.util.concurrent.locks.Lock;
+ import java.util.concurrent.locks.ReentrantLock;

class Salesperson implements Runnable {
    private int amount = 7;
+   Lock l = new ReentrantLock();

    @Override
    public void run() {
        while (amount &gt; 0) {
+           l.lock();
            if (amount &gt; 0) {
                try {
                    Thread.sleep(1);
                } catch (Exception e) {
                }
                System.out.println(Thread.currentThread().getName() + &quot; is selling &quot; + amount);
                amount--;
            }
+           l.unlock();
        }
    }
}
</code></pre>
<p>更好的模板：</p>
<pre><code class="lang-java">lock.lock();
try {
    // 可能出现线程安全问题的代码
} finally {
    lock.unlock(); // 无论程序是否异常，都会释放锁
}
</code></pre>
<h2 id="线程通信——等待唤醒机制"><a href="#线程通信——等待唤醒机制" class="headerlink" title="线程通信——等待唤醒机制"></a>线程通信——等待唤醒机制</h2><p>线程同步只能解决线程并发执行时的线程安全问题，但锁释放后，CPU仍然是按照默认情况随机切换线程（抢占式调度）。</p>
<p>但我们有时需要多个线程按一定的前后规律来执行，此时为了协调不同线程间的工作，需要在线程间建立沟通渠道；有时当多个线程在操作共享数据时，不应该随机地对共享数据进行争夺，而应该通过线程间通信实现更有效的利用。java为此提供了线程通信方法——等待唤醒机制</p>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>等待唤醒机制（wait/notify）是一种线程间的通信协作机制。当一个线程进入某些状态时暂时不适合继续执行，则按需要进入等待状态（wait），直至其他线程执行后，状态适合原线程继续执行，再将原线程唤醒（notify）。</p>
<p>线程通信用于线程间，故必须发生在<strong>同步代码内部</strong>，且与<strong>同步代码的锁对象</strong>对应。而由于任意对象都可以作为锁，故在Java中，与线程通信相关的几个方法，都定义在<code>java.lang.Object</code>中。Object的常用线程通信方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">wait()</td>
<td style="text-align:center">当前线程等待notify唤醒</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center"><em>wait(long timeout)</em></td>
<td style="text-align:center">当前线程等待notify唤醒或计时超过timeout自定唤醒</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">notify()</td>
<td style="text-align:center">唤醒在此对象监视器上等待的随机单个线程</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">notifyAll()</td>
<td style="text-align:center">唤醒在此对象监视器上等待的所有线程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait &amp; notify"></a>wait &amp; notify</h3><p>注：</p>
<ol>
<li>notify()和notifyAll()都是唤醒在<strong>对应对象监视器</strong>上的线程，唯一的区别在于——前者是<strong>随机单个</strong>线程，后者是<strong>所有</strong>线程。故后文不在单独说明notifyAll()，仅介绍notify()。</li>
<li>本节所提及的各种线程状态在后文有详细说明。</li>
</ol>
<p>wait()和notify()方法的使用方法及详细流程如下：</p>
<ol>
<li>若当前状态不适合本线程继续执行：<ol>
<li>本线程在<strong>对象Obj</strong>上执行<strong>同步代码（synchronized）</strong>，通过调用wait()方法，暂停本线程的执行</li>
<li>本线程进入<strong>对象Obj的Wait Set（等待池）</strong>等待，并释放已获得的<strong>对象Obj的锁</strong></li>
<li>本线程变为WAITING状态，不再运行，不再参与调度，不再竞争锁，即不再占用CPU资源。</li>
</ol>
</li>
<li>直至其他线程在<strong>对象Obj</strong>上执行<strong>同步代码（synchronized）</strong>时，状态适合原线程继续执行：<ol>
<li>通过其他线程在<strong>对象Obj</strong>上调用notify()将对象唤醒，（其他线程继续执行）</li>
<li>原线程从<strong>对象Obj的Wait Set（等待池）</strong>释放出来，重新进入<strong>Lock Set（锁池）</strong>，变为BLOCKED状态</li>
<li>直至重新抢到<strong>对象Obj的锁</strong>再恢复执行抢占CPU的调度，变为RUNNABLE状态。</li>
</ol>
</li>
</ol>
<p>注：</p>
<ol>
<li>即使对象Obj的Wait Set（等待池）中只有一个线程在等待，被notify唤醒，该线程也不能立即恢复执行。因为该线程并不持有锁（执行唤醒操作的线程持有锁），而是应该先进入Lock Set（锁池），等到重新抢到对象Obj的锁，才能恢复执行抢占CPU的调度。</li>
<li>锁，Wait Set（等待池），Lock Set（锁池）都是和对象Obj<strong>一一对应</strong>的，故使用wait()和notify()方法时，必须要由<strong>同一个锁对象</strong>调用。</li>
<li>wait()和notify()方法必须要在同步代码（synchronized）中使用。原因同上，必须要通过锁对象调用。</li>
</ol>
<h3 id="线程通信示例"><a href="#线程通信示例" class="headerlink" title="线程通信示例"></a>线程通信示例</h3><p>最典型的线程通信的例子就是生产者与消费者的例子，仍旧是卖票，不过新增一个生产票的Producer线程，票卖完就生产，没卖完就休息，具体代码如下：</p>
<pre><code class="lang-java">/* Office.java */
class Office {
    public static void main(String args[]) {
        Tickets t = new Tickets();
        Producer p = new Producer(t);
        Salesperson s = new Salesperson(t);
        new Thread(p, &quot;Producer-1&quot;).start();
        for (int i = 1; i &lt;= 3; i++) {
            new Thread(s, &quot;Salesperson-&quot; + i).start();
        }
    }
}

/* Tickets.java */
class Tickets {
    public int amount = 0;
    public int order = 0;

    public void log(String desc) {
        System.out.println(Thread.currentThread().getName() + &quot; : &quot; + desc);
    }

    public void thread_wait() {
        try {
            wait();
        } catch (Exception e) {
        }
    }

    public synchronized void product() {
        if (order &lt; amount) { // 有存票，生产票线程等待
            log(&quot; wait&quot;);
            thread_wait();
        }
        int increase = (int) (Math.random() * 5);
        for (int i = 1; i &lt; increase; i++)
            log(&quot; products ticket-&quot; + (++amount));
        notifyAll();
    }

    public synchronized void sell() {
        if (order &gt;= amount) { // 无存票，售票线程等待
            log(&quot; wait&quot;);
            thread_wait();
        }
        log(&quot; sells ticket-&quot; + (++order));
        notifyAll();
    }
}

/* Producer.java */
class Producer implements Runnable {
    Tickets t = null;

    public Producer(Tickets t) {
        this.t = t;
    }

    @Override
    public void run() {
        while (true) {
            t.product();
        }
    }
}

/* Salesperson.java */
class Salesperson implements Runnable {
    Tickets t = null;

    public Salesperson(Tickets t) {
        this.t = t;
    }

    @Override
    public void run() {
        while (true) {
            t.sell();
        }
    }
}
</code></pre>
<p>其运行结果如下：</p>
<blockquote>
<p>Producer-1 :  products ticket-1<br>  Producer-1 :  products ticket-2<br>  Producer-1 :  wait<br>  Salesperson-2 :  sells ticket-1<br>  Salesperson-2 :  sells ticket-2<br>  Salesperson-2 :  wait<br>  Salesperson-3 :  wait<br>  Salesperson-1 :  wait<br>  Producer-1 :  products ticket-3<br>  Producer-1 :  wait<br>  Salesperson-3 :  sells ticket-3<br>  Salesperson-3 :  wait<br>  Producer-1 :  products ticket-4<br>  Producer-1 :  products ticket-5<br>  Producer-1 :  products ticket-6<br>  Producer-1 :  wait<br>  Salesperson-1 :  sells ticket-4<br>  Salesperson-1 :  sells ticket-5<br>  Salesperson-1 :  sells ticket-6<br>  Salesperson-1 :  wait<br>  Producer-1 :  products ticket-7<br>  …</p>
</blockquote>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程同步和线程通信使得线程有许多不同的状态，以下具体地分析线程的状态及其转换过程：</p>
<h3 id="线程状态-1"><a href="#线程状态-1" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程的状态及其简单说明如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">线程状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NEW<br>(新建)</td>
<td style="text-align:center">刚被创建的线程。<br>但至今尚未启动（还没调用start()方法）</td>
</tr>
<tr>
<td style="text-align:center">RUNNABLE<br>(可运行)</td>
<td style="text-align:center">在java虚拟机中可执行的线程。<br>但具体是否正在执行取决于是否抢占到了CPU的调度</td>
</tr>
<tr>
<td style="text-align:center">BLOCKED<br>(阻塞)</td>
<td style="text-align:center">受阻塞的线程。线程试图获得对象锁，但该对象锁被其他的线程持有，<br>故该线程受阻塞并等待锁的释放，直至持有该锁才转为RUNNABLE</td>
</tr>
<tr>
<td style="text-align:center">WAITING<br>(无限等待)</td>
<td style="text-align:center">无限期等待的线程。直至接收到唤醒通知——<br>另一个线程执行Object.notify()或Object.notifyAll()。<em>（不能自动唤醒）</em></td>
</tr>
<tr>
<td style="text-align:center">TIMED_WAITING<br>(计时等待)</td>
<td style="text-align:center">计时等待的线程。根据Thread.sleep(long)或Object.wait(long)<br>设定的超时参数，一直保持该状态直至超时期满或接收到唤醒通知</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED<br>(被终止)</td>
<td style="text-align:center">已终止的线程。因为run方法()正常结束或产生了未捕获的异常</td>
</tr>
</tbody>
</table>
</div>
<h3 id="状态转换过程"><a href="#状态转换过程" class="headerlink" title="状态转换过程"></a>状态转换过程</h3><p><img src="https://cdn.jsdelivr.net/gh/CN-DXTZ/Blog-Img-Bed/PicGo/Thread_2_2.png" alt="Thread_2_2.png"></p>

    </div>

    <div class="post-nav">
        <span class="post-nav-prev">
            
            <a href="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" rel="prev" title="网络编程入门">
                <i class="iconfont icon-houtui"></i>网络编程入门
            </a>
            
        </span>
        <span class="post-nav-next">
            
            <a href="/2020-%E5%B9%B4-3-%E6%9C%88/" rel="next" title="2020 年 3 月">
                2020 年 3 月<i class="iconfont icon-qianjin"></i>
            </a>
            
        </span>
    </div>
</article>

<div class="post-toc">
    <div class="toc-title">
        <i class="iconfont icon-mulu"></i>
        文章目录
        <span>
            <i class="iconfont icon-houtui"></i>
        </span>
    </div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的简单使用"><span class="toc-number">1.2.</span> <span class="toc-text">线程的简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#继承Thread"><span class="toc-number">1.2.1.</span> <span class="toc-text">继承Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现Runnable"><span class="toc-number">1.2.2.</span> <span class="toc-text">实现Runnable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步——锁机制"><span class="toc-number">2.</span> <span class="toc-text">线程同步——锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全之数据共享"><span class="toc-number">2.1.</span> <span class="toc-text">线程安全之数据共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的数据共享"><span class="toc-number">2.1.1.</span> <span class="toc-text">线程的数据共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据共享的线程安全问题"><span class="toc-number">2.1.2.</span> <span class="toc-text">数据共享的线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的同步与互斥"><span class="toc-number">2.1.3.</span> <span class="toc-text">线程的同步与互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">2.2.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步代码块"><span class="toc-number">2.2.1.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方法"><span class="toc-number">2.2.2.</span> <span class="toc-text">同步方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">2.3.</span> <span class="toc-text">Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程通信——等待唤醒机制"><span class="toc-number">3.</span> <span class="toc-text">线程通信——等待唤醒机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待唤醒机制"><span class="toc-number">3.1.</span> <span class="toc-text">等待唤醒机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-amp-notify"><span class="toc-number">3.2.</span> <span class="toc-text">wait &amp; notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程通信示例"><span class="toc-number">3.3.</span> <span class="toc-text">线程通信示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程状态"><span class="toc-number">4.</span> <span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程状态-1"><span class="toc-number">4.1.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转换过程"><span class="toc-number">4.2.</span> <span class="toc-text">状态转换过程</span></a></li></ol></li></ol>
</div>
</section>	

    </main>

    <div class="footer">
	<div class="platform">
		
			
			
				<a class="iconfont icon-gmail"  href="mailto:dengbin1213@gmail.com" target="_blank"></a>
							
		
			
			
				<a class="iconfont icon-github"  href="https://github.com/CN-DXTZ" target="_blank"></a>
							
		
			
			
				<a class="iconfont icon-zhihu"  href="https://www.zhihu.com/people/DXTZ/" target="_blank"></a>
							
		
			
			
				<a class="iconfont icon-qq-email"  href="mailto:2924380441@qq.com" target="_blank"></a>
							
		
			
							
		
			
							
		
	</div>
	
	<div class="copyright-info">
			<span>Copyright © 2020 - 2020</span>
			<a href="/">DXTZ</a> 
	</div>
</div>

    <div class="after-footer">

    
<script src="/js/navbar.js"></script>


    
<script src="/js/littleCode.js"></script>


    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/instantpage.min.js"type="module"></script>

    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/jquery.min.js"></script>

    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/vanilla-back-to-top.min.js"></script>
    
<script src="/js/addBackToTop.js"></script>


    
        <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist/source/js/third%20party/jquery.fancybox.min.js"type="module"></script>
        
<script src="/js/jquery.fancybox.image.js"></script>


        
<script src="/js/jquery.toc.js"></script>

    

    <script src="//cdn.jsdelivr.net/gh/CN-DXTZ/hexo-theme-Minimalist@V1.2/source/js/third%20party/prism.min.js" type="module"></script>

</div>
</body>

</html>